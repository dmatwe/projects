**Виды требований к программному продукту**
<br/>
[1. Бизнес-требования](#т1)
<br/>
[2. Бизнес-правила](#т2)
<br/>
[3. Пользовательские требования](#т3)
<br/>
[4. Системные требования](#т4)
<br/>
[5. Функциональные требования](#т5)
<br/>
[6. Нефункциональные требования](#т6)
<br/>
[7. Ограничения](#т7)
<br/>
[8. Внешние интерфейсы](#т7)

**Классификация НФТ**
<br/>
[1. Производительность](#нфт1)
<br/>
[2. Безопасность](#нфт2)
<br/>
[3. Масштабируемость](#нфт3)
<br/>
[4. Надежность](#нфт4)
<br/>
[5. Совместимость](#нфт5)
<br/>
[6. Доступность](#нфт6)
<br/>
[7. Особенности хранения данных](#нфт7)
<br/>
[8. Концептуальная целостность](#нфт8)
<br/>
[9. Ремонтопригодность](#нфт9)
<br/>
[10. Возможность повторного использования](#нфт10)
<br/>
[11. Удобство использования](#нфт11)
<br/>
[12. Возможность поддержки](#нфт12)
<br/>
[13. Тестируемость](#нфт13)

**Архитектура**
<br/>
[1. Архитектурные слои](#а1)
<br/>
[2. Компонент](#а2)
<br/>
[3. Интерфейс](#а3)
<br/>
[4. Разделение компонентов](#а4)
<br/>
[5. Разделение по принципу согласованного изменения](#а5)
<br/>
[6. Разделение по субдоменам](#а6)
<br/>
[7. По единой функциональности](#а7)
<br/>
[8. Монолит](#а8)
<br/>
[9. SOA](#а9)
<br/>
[10. Микросервисы](#а10)
<br/>
[11. Хорошая архитектура](#а11)
<br/>
[12. Плохая архитектура](#а12)


**Интеграции**
<br/>
[1. Интеграция](#и1)
<br/>
[2. File transfer](#и2)
<br/>
[3. Shared Database](#и3)
<br/>
[4. RPC](#и4)
<br/>
[5. Message](#и5)
<br/>
[6. Синхронное взаимодействие](#и6)
<br/>
[7. Асинхронное взаимодействие](#и7)
<br/>
[8. Асинхронное взаимодействие с callback](#и8)

**Брокеры очередей**
<br/>
[1. Принцип работы очередей сообщений](#б1)
<br/>
[2. Применение брокеров](#б2)
<br/>
[3. Недостатки брокеров](#б3)
<br/>
[4. Брокер сообщений](#б4)
<br/>
[5. Паттерн Hello world](#б5)
<br/>
[6. Паттерн Очередь](#б6)
<br/>
[7. Паттерн Подписка](#б7)
<br/>
[8. Паттерн Маршрутизация](#б8)
<br/>
[9. Паттерн Топики](#б9)
<br/>
[10. Паттерн Запрос-ответ](#б10)
<br/>
[11. Сравнение брокеров Kafka/RabbitMQ/Redis](#б11)

**KAFKA VS RabbitMQ**
<br/>
[1. Kafka](#rk1)
<br/>
[2. RabbitMQ](#rk2)
<br/>
[3. KAFKA VS RabbitMQ](#rk3)

**SOAP**
<br/>
[1. SOAP](#SOAP1)
<br/>

**REST API**
<br/>
[1. REST API ЭТО](#rest1)
<br/>
[2. Первый принцип - Клиент-серверная архитектура](#rest2)
<br/>
[3. Stateless](#rest3)
<br/>
[4. Кэширование](#rest4)
<br/>
[5. Единообразие интерфейса ](#rest5)
<br/>
[6. Cлоистая архитектура](#rest6)
<br/>
[7. Код по запросу](#rest7)
<br/>
[8. HTTP/HTTPS/TLS](#rest8)
<br/>
[9. URL](#rest9)
<br/>
[10. Методы POST/GET/PATCH/PUT/DELETE](#rest10)
<br/>
[11. Идемпотентность](#rest11)
<br/>
[12. HTTP](#rest12)
<br/>

**Базы Данных**
<br/>
[1. Транзакция](#bd1)
<br/>
[2. ACID](#bd2)
<br/>
[3. Реляционная база данных](#bd3)
<br/>
[4. NoSQL](#bd4)
<br/>
[5. МРР СУБД](#bd5)
<br/>
[6. CAP Теорема](#bd6)
<br/>
[7. Шардинг/Нода/Кластер/Репликация](#bd7)
<br/>
[8. OLAP](#bd8)
<br/>
[9. OLTP](#bd9)
<br/>

**Mind map требований**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/map1.png)

«Требование – это удобное представление потребности. Требования направлены на понимание того, какую ценность можно получить, если требование будет выполнено.» BABOK (2015)


![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/req.png)

<a name="т1"></a>
***1. Бизнес-требования*** (BRQ- business requirements questionnaire) –   информация, в совокупности
описывающая потребность бизнес заказчика, 
а также бизнес возможности и бизнес цели
<br/>
***Примеры:***
<br/>
Увеличить продажи отдела digital-маркетинга на 25% за год.
<br/>
Операционные затраты должны сократиться на 30% после внедрения новой системы.

<a name="т2"></a>
***2. Бизнес-правила*** - это требования, установленные в бизнес-практике, законодательстве или отрасли, которым мы обязаны следовать при реализации нашей системы.
<br/>
***Примеры:***
<br/>
Сайт интернет-магазина должен соответствовать требованиям федерального закона (Закон "О персональных данных" N 152-ФЗ).
<br/>
Клиент компании может оформить заказ с оплатой курьеру. 

<a name="т3"></a>
***3. Пользовательские требования*** (URQ - user requirements questionnaire)- описывают 
цели и задачи, которые пользователи должны иметь возможность выполнять с помощью системы\продукта
<br/>
***Примеры:***
<br/>
Сотрудники первой линии поддержки должны иметь доступ к user-friendly интерфейсу для мониторинга  и решения инцидентов.
<br/>
Сотрудники склада должны иметь возможность формировать промежуточные метрики по расходам сырья.

<a name="т4"></a>
***4. Системные требования*** (SRQ - system requirements questionnaire) – это требования к продукту, который включает в себя несколько подсистем. Иными словами, это требования, описывающие взаимодействие этих подсистем.
<br/>
***Примеры:***
<br/>
у нас есть интернет-банк, и требуется, чтобы доступ к операциям со счетом осуществлялся через единый сервер приложений. 
<br/>
С этим сервером могут взаимодействовать различные клиентские приложения: интернет-банк в браузере пользователя, мобильное приложение или отдельное Java-приложение на компьютере пользователя. 
<br/>
Это требование описывает систему в целом, и дает нам понимание, что есть несколько вариантов клиентской части приложения, но все они должны работать с единым сервером.

<a name="т5"></a>
***5. Функциональные требования*** (FRQ – functional requirements questionnaire) - описывают
поведение системы или продукта в определенных
условиях. Функциональные требования 
определяют, что разработчики должны создать, 
чтобы пользователи могли выполнять свои задачи
<br/>
***Примеры:***
<br/>
Система должна сохранять информацию по инцидентам и направлять уведомления о сбоях пользователям.
<br/>
Система должна собирать метрики и формировать из них отчет с заданным временным интервалом.

<a name="т6"></a>
***6. Нефункциональные требования*** (NFR - non-functional requirements) описывают как должна работать система или программный продукт и какими свойствами она должна обладать, а также описывают атрибуты качества, ограничения, взаимодействия с внешними интерфейсами.
Атрибуты качества (quality attributes) представляют собой дополнительное описание функций продукта, выраженное через описание его характеристик, важных для пользователей или разработчиков, такие как производительность, надежность, масштабируемость, возможность интеграции c внешними системами.
<br/>
***Примеры:***
<br/>
Система должна обеспечивать интеграцию с сервисами доставки для отправки заказов клиентам.
<br/>
Система должна выдерживать 5000 заказов в день и одновременно 100 сессий.

<a name="т7"></a>
***7. Ограничения*** - представляют собой условия, которые модифицируют требование или набор требований, сужая тем самым выбор возможных решений. Наиболее известными ограничениями являются, технические ограничения, которые часто фиксируются в техническом задании, исходя из возможностей, которыми обладают заказчик или разработчик.
<br/>
***Примеры:***
<br/>
Сервер приложений сайта должен разрабатываться на языке Java. Почему такое требование может быть предъявлено? Возможно, потому что у заказчика имеется большое количество специалистов, способных сопровождать работу системы, написанной на этом языке, а все остальные серверы приложений заказчика также функционируют в этой среде.
<br/>
ПО должно устанавливаться на определенную версию операционной системы (ОС Ubuntu Server 14.04.6).

<a name="т8"></a>
***8. Внешние интерфейсы*** - это описание интерфейса между системой и пользователем, другой системой или оборудованием. Обычно внешние интерфейсы с другими системами уже описаны в виде спецификаций, которым нужно следовать при разработке продукта.
<br/>
***Примеры***:
API социальных сетей для автоматического репоста публикаций с сайта на страничку компании в Facebook. Таким образом, нет необходимости вручную копировать новости, специальное приложение сделает это автоматически.
<br/>
Спецификация взаимодействия с платежным агрегатором для обработки онлайн-платежей на сайте интернет-магазина. Это описание внешнего интерфейса представляет собой определенную спецификацию передачи данных.


**Классификация НФТ**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/nft.png)

<a name="нфт1"></a>
***1. Производительность*** - это показатель скорости реакции системы на выполнение любого действия в течение заданного интервала времени. Его можно измерить с точки зрения задержки или пропускной способности. Задержка - это время, необходимое для ответа на любое событие. Пропускная способность - это количество событий, которые происходят в течение заданного промежутка времени.
<br/>
***Пример:*** 
<br/>
Система должна выводить пользователю сообщение о подтверждении в среднем за 3 секунды и не более чем через 6 секунд после того, как пользователь отослал информацию системе.
<br/>
***Чек-лист***
<br/>
какие функции системы завязаны/влияют на взаимодействие с внешними (по отношению к предприятию-заказчику) агентами: клиентами, гос. органами.
<br/>
в какие периоды времени могут происходить пиковые нагрузки исходя из бизнесконтекста и процессов.

<a name="нфт2"></a>
***2. Безопасность*** - это способность системы предотвращать злонамеренные или случайные действия, выходящие за рамки запланированного использования, а также предотвращать раскрытие или потерю информации. Защищенная система направлена на защиту активов и предотвращение несанкционированного изменения информации.
<br/>
***Пример:***
Допускается использование только учетных записей с доменной аутентификацией ActiveDirectory
<br/>
***Чек-лист***
<br/>
что случится, если данные по функции будут доступны всем.
<br/>
есть данные, которые не должны быть доступны и почему

<a name="нфт3"></a>
***3. Масштабируемость***  - это способность системы либо справляться с увеличением нагрузки без влияния на производительность системы, либо возможность быстрого расширения.
<br/>
***Пример:***
<br/>
Система должна обеспечивать масштабируемость до 1000 пользователей с сохранением текущего уровня производительности
***Чек-лист***
<br/>
 уточнить про масштабы текущего внедрения: в каких орг. единицах и пр.
<br/>
будет ли дальнейшее расширение использования системы.
<br/>
какой тренд (динамика) развития бизнес-направления.

<a name="нфт4"></a>
***4. Надежность*** - это способность системы оставаться в рабочем состоянии в течение долгого времени. Надежность измеряется как вероятность того, что система не откажется выполнять свои функции в течение определенного интервала времени.
<br/>
***Пример:***
<br/>
Система должна обеспечивать время восстановление после сбоя не более 2 часов
<br/> 
***Чек-лист***
<br/>
какие последствия повлечет за собой отключение (временная
недоступность) разрабатываемой системы или функции системы.
<br/>
сколько система может не работать (если может).

<a name="нфт5"></a>
***5. Совместимость*** - это способность системы или различных систем успешно работать, обмениваясь информацией с другими внешними системами, написанными и управляемыми внешними сторонами. Совместимая система упрощает обмен и повторное использование информации как внутри компании, так и за ее пределами.
<br/>
***Пример:***
<br/>
Система должна функционировать на ОС Windows XP/7/8/10
<br/> 
***Чек-лист***
<br/>
по данному пункту лучше осуществлять коммуникацию с архитекторами и
командой разработки. От заказчика в лучшем случае можно получить
ограничения по бюджету.

<a name="нфт6"></a>
***6. Доступность*** - определяет время, в течение которого система функционирует и работает. Его можно измерить как процент от общего времени простоя системы за заранее определенный период. Доступность будет зависеть от системных ошибок, проблем с инфраструктурой, злонамеренных атак и загрузки системы.
<br/>
***Пример:***
<br/>
Система должна быть доступна 98% времени в период 5:00 - 00:00, и 90% времени в период 00:00 - 5:00, за исключением времени планового обслуживания
<br/> 
***Чек-лист***
<br/>
требуется ли доступность 24/7 или бизнес-процессы имеют разрывы
(например выходные дни)
<br/>
будет ли система использоваться в разных часовых поясах.

<a name="нфт7"></a>
***7. Особенности хранения данных*** - это все, что связано с резервированием, с доступом к данным, со скоростью доступа к данным.
<br/>
***Пример:***
<br/>
Раз в неделю необходимо производить резервное копирование данных и хранить их в течение трех лет.

<a name="нфт8"></a>
***8. Концептуальная целостность*** - определяет последовательность системы и последовательность всего дизайна. Сюда входит способ разработки компонентов или модулей, а также такие факторы, как стиль кодирования и именование переменных.
Пример:
GUI (graphical user interface) системы должен разрабатываться на основе стандартной библиотеки (корпоративный UI Kit)

<a name="нфт9"></a>
***9. Ремонтопригодность*** - это возможность быстрого внесения изменений в систему, насколько сложно внести какие-либо изменения. 
***Пример:***
Требования к тому, что система должна позволять вносить изменения без кодинга, только через настройки.

<a name="нфт10"></a>
***10. Возможность повторного использования*** - определяет способность компонентов и подсистем быть подходящими для использования в других приложениях и в других сценариях. Возможность повторного использования сводит к минимуму дублирование компонентов, а также время внедрения.
***Пример:***
Код на котором разработано приложение должен быть написан с использованием стандартных библиотек и фреймворков, чтобы его можно было легко переносить на другие проекты.

<a name="нфт11"></a>
***11. Удобство использования*** определяет, насколько хорошо приложение соответствует требованиям пользователя и потребителя, будучи интуитивно понятным, простым в локализации и глобализации, обеспечивая хороший доступ для пользователей с ограниченными возможностями и приводя к хорошему общему пользовательскому опыту.
<br/>
***Пример:***
<br/>
Интерфейс системы должен быть выполнен в темных цветовых тонах, т.к. эксплуатация пользователем будет осуществляться в условиях низкого уровня освещения»
<br/> 
***Чек-лист***
<br/>
Выявить круг конечных пользователей, провести первичный анализ
условий их работы и особенности пользовательского поведения.

<a name="нфт12"></a>
***12. Возможность поддержки*** - это способность системы предоставлять информацию, полезную для выявления и решения проблем, когда она работает неправильно.
***Пример:***
Требование к логированию ошибок и к сбору информации, который в итоге поможет поддерживать систему и анализировать ошибки.

<a name="нфт13"></a>
***13. Тестируемость*** - это мера того, насколько легко создать критерии тестирования для системы и ее компонентов и выполнить эти тесты для определения соответствия критериям. Хорошая тестируемость повышает вероятность того, что сбои в системе могут быть локализованы своевременно и эффективно.
***Пример:***
Требование к тому, насколько легко тестировать нашу систему, нужны ли для этого какие-то специальные инструменты, софт или, например, к возможности автоматизированного тестирования.

<br/>

**Прикладная архитектура**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/maparch.png)

***1. Прикладная архитектура информационной системы*** – это
форма, которая придаётся системе её создателями

<a name="а1"></a>

***Форма системы*** образуется посредством деления системы на
компоненты, и определяется их организацией и способами
взаимодействия друг с другом и внешними системами

***Цель создания такой формы*** – упростить разработку,
развёртывание и сопровождение программной системы
Неверные архитектурные решения труднее всего поддаются
изменениям на этапе разработки и эксплуатации системы


***Концепция слоёв*** – подход, используемый при проектировании сложных
систем, предполагающий разделение системы на более простые части

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/client_server.png)

***Расслоение системы***
<br/>
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/layer.png)


***Дополнительные слои***
<br/>
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/dop_layer.png)

<a name="а2"></a>

***2. Логический компонент*** - замещаемая часть системы, которая соответствует некоторому набору интерфейсов и
обеспечивает их реализацию

***Физический компонент*** – это единица развёртывания, представляющая наименьшую сущность, которую можно развернуть в
составе системы. Например – jar-файлы, dll-файлы, exe-файлы. С точки зрения разработки, компонент – это
отдельный проект/модуль исходного кода системы

<a name="а3"></a>

***3. Интерфейс*** – это набор операций, которые специфицируют сервис (так называемая спецификация сервиса)
Интерфейс сам по себе не содержит никакой прикладной логики. Он определяет операции (методы), которые
поддерживает компонент.
<br/>
В компоненте реализуется логика, описанных в интерфейсе операций.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/intface.png)

<a name="а4"></a>

***4. Зачем разделять систему на компоненты?*** 

Обеспечить независимую разработку и развёртывание в случае большой команды разработчиков
<br/>
Снизить влияние изменений, вносимых в одну часть системы, на другую часть системы
<br/>
Иметь возможность заменять один компонент на другой – аналогичный по интерфейсу, но отличный
по реализации
<br/>
Иметь возможность тестировать отдельные части системы без привлечения других частей

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp.png)

***Принципы разделения компонентов*** 

***5. Разделение по принципу согласованного изменения***  –
один компонент должен реализовывать бизнес-логику
вариантов использования для одного актора – т.е.
только этот актор может инициировать изменение
этого компонента

<a name="а5"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp1.png)

***6. Разделение по субдоменам (bounded contexts)***
 – внутри
одного компонента реализуется логика работы с
ограниченным контекстом предметной области

<a name="а6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp2.png)


***7. Разделение по принципу единой функциональности*** и
переиспользования – если у нескольких компонентов
есть общие функции, то эти функции могут быть
вынесены в отдельный компонент

<a name="а7"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp3.png)

**8. Монолит**

<a name="а8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/monmap.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/monolit.png)

***Преимущества и недостатки монолита***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/monolit1.png)

***Применение***

Небольшая команда разработчиков

Система должна решать ограниченный круг бизнес-задач

Функциональность системы не планирует расширятся на другие предметные области

Для MVP в гибких методологиях разработки (принцип Monolith First)

**9. SOA**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soamap.jpg)

<a name="а9"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soa.png)

Взаимодействие между сервисами
осуществляется через ***корпоративную шину данных (ESB)*** по унифицированному
протоколу обмена (например, SOAP).
Сервисы публикуют свои интерфейсы на
шине

***Сервисы ничего не знают друг о друге***, но
знают об интерфейсах и методах, которые
предоставляет ESB

На ESB также публикуются различные
служебные сервисы, обеспечивающие
журналирование, авторизацию, мониторинг
и т.д.

Подход ESB предполагает ***единое хранилище данных***

***Преимущества и недостатки SOA***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soa1.png)

***Применение***

Интеграция разнородных приложений в большой корпорации

Много команд разработки

Множество решаемых бизнес-задач

**10. Микросервисы**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/micromap.jpg)

<a name="а10"></a>

***Микросервис*** представляет
собой сочетание как сервиса
бизнес-логики, так и средств
хранения данных

Прямое ***межсервисное взаимодействие должно быть
сведено к минимуму***. Иначе микросервисная архитектура
превратится в модульный монолит

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc.png)


***Преимущества и недостатки Микросервисов***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc1.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc2.png)


***Применение***

Реализация больших корпоративных систем с нуля

Для реализации множеством команд разработчиков

Множество решаемых бизнес-задач и предметных областей, которые должны работать в системе
независимо, но требуют постоянной интеграции


![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/archmapad.jpg)

**11. Хорошая архитектура**

<a name="а11"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/arch1.png)

**12. Плохая архитектура**

<a name="а12"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/arch2.png)

**Интеграции**

<a name="и1"></a>

***1. Интеграция*** – передача данных от одной системы в другую

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int.png)

***2. File transfer***
<a name="и2"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int1.png)

***Применение:***
<br/>
Обмен между системами происходит раз в сутки и 2 системы не user-friendly для интеграций


***3. Shared Database***
<a name="и3"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int2.png)

***Применение:***
<br/>
Много систем, необходимо читать, записывать и архивировать данные 
<br/>
Система не знает пришли/записались ли данные и постоянно отправляет запрос в БД


***4. Remote Procedure Call (RPC)***
<a name="и4"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int3.png)

***Применение:***
<br/>
Система А вызывает удаленную функцию у системы B, данные не сохраняются  (REST/SOAP APi)
<br/>
Обе системы должны быть доступны

***5. Message***
<a name="и5"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int4.png)

***Применение:***
<br/>
Транспорт данных быстрее чем у БД, данные временно хранятся в брокере, есть оповещение действий (Kafka/Rabbit MQ)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int5.png)


***Синхронное взаимодействие***
<a name="и6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/sin.png)


***Асинхронное взаимодействие***
<a name="и7"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/asin.png)

***Асинхронное взаимодействие с callback***
<a name="и8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/asinc.png)

***Принцип работы очередей сообщений***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mapbrok.jpg)

<a name="б1"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker.png)

***Применение брокеров***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker2.png)

***Недостатки брокеров***
<a name="б3"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker3.png)

***Брокер сообщений***
<a name="б4"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker1.png)


***Паттерн Hello world***
<a name="б5"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb1.png)

***Паттерн Очередь***
<a name="б6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb2.png)

2 Consumer получают сообщения из одной очереди в здананом порядке
<br/>
С помощью партиций можно распределять нагрузку

***Паттерн Подписка***
<a name="б7"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb3.png)

2 очереди с разными типами сообщений для каждого Consumer

***Паттерн Маршрутизация***
<a name="б8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb4.png)

Реализуется сложная логика мапинга типов очередей
<br/>
2 пула: пул для всех ошибок и пул только для критических ошибок

***Паттерн Топики***
<a name="б9"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb5.png)

Более сложная фильтраци (например через регулярки)

***Паттерн Запрос-ответ***
<a name="б10"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb6.png)

2 очереди для запроса и ответа (RabbitMq)

***Сравнение брокеров***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/krk.jpg)

<a name="б11"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker4.png)

***Персистентные структуры данных (англ. persistent data structures)*** — это структуры данных, которые при внесении в них изменений сохраняют доступ ко всем своим предыдущим состояниям.

***Kafka*** - масштабируемая, производительная и гибкая система передачи сообещний и управления очередями для:
<a name="rk1"></a>

***1)Связи микросерисов между собой***
<br/>
***Пример:*** подписка триггер на обновления других частей системы  

***2)Организация потоков данных*** 
<br/>
***Пример:*** стрим событий, при котором на каждом этапе производятся различные манипуляции с данными 

***3)Агрегация данных***
<br/>
***Пример:*** в Kafka формировать метрики и результат записывать в БД

***4)Сбор логов***
<br/>
***Пример:*** краткосрочное хранение логов для разгрузки бд и систем логирования   

***RabbitMQ***
<a name="rk2"></a>

<br/>
Брокер сообщений который состоит из:
<br/>
Mnesia - распределенная СУБД реального времени, написанная на языке программирования Erlang. 
<br/>
Сервер, библиотеки и плагины
<br/>
Имеет возможность горизонтального масштабирования 

***Процесс отправки сообщений:***
<br/>
Publisher -> exchange 
<br/>
1.Отправители отправляют сообщения на обменники
<br/>
2.Обменники отправляют полученные сообщения на другие обменники и в очереди 
<br/>
3.При получении сообщений rabbitMq отправляет подтверждение отправителям
<br/>
4.Получатели постоянно поддерживают TCP-соединение с RabbitMq и объявляют какую очередь они получают 
<br/>
5. rabbitMq проталкивает push сообщения получателям 
<br/>
6.Получатели отправляют подтверждение успеха или ошибки получения сообщения
<br/>
7.После успешного получения сообщение удаляется из очереди


***KAFKA VS RabbitMQ***
<a name="rk3"></a>


| Тип                    | Kafka                                                                                                                                                                                                                                              | RabbitMQ                                                                                                                                                                                                                                                                 |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Обработка сообщений    | Добавляет сообщения журнал, а получатель сам забирает сообщение                                                                                                                                                                                    | Помещает сообщение в очередь (FIFO first input, first output) и отслеживает статус                                                                                                                                                                                       |
| Удаление               | Хранит сообщение до плановой чистки журнала (может сохранять историчность)                                                                                                                                                                         | Удаляет сообщение после его доставки получателю                                                                                                                                                                                                                          |
| Распределение нагрузки | Балансировка нагрузки выполняется автоматически через распределение получателей по partition топика.<br>Позволяет объединять сообщения в пакеты<br>Считается более адаптивной к масштабированию обеспечивая ежедневный обмен миллиардами сообщений | Из-за Push модели возможно переполнение получателей.<br>Каждый получатель запрашивает разное кол-во сообщений, распределение работы может быть неравномерным и возможны задержки.<br>Необходимо ввести ограничения на кол-во скопившихся неподтвержденных сообщений QOS. |
| Маршрутизаиця          | 1 способ записи сообщений на диск без маршрутизации                                                                                                                                                                                                | 4 способа маршрутизации на разные обменники для постановки в различные очереди                                                                                                                                                                                           |
| Хранение данных        | Последовательная запись сообщений в реплеку журнала                                                                                                                                                                                                | Поддерживает порядок в произвольных группах/событиях                                                                                                                                                                                                                     |
| Главное отличие        | Тупой сервер, умный клиент,<br>т.е. логика работы с сообщениями на клиентской стороне                                                                                                                                                              | Умный сервер, тупой клиент,<br>т.е. брокер сам обеспечивает всю логику работы с сообщениями                                                                                                                                                                              |



***Где что использовать:***

***Kafka*** - большая нагрузка, нужна историчность данных.
<br/>
***RabbitMQ*** - real-time, если нужен быстрый обмен сообщениями.


**SOAP**

<a name="SOAP1"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soapmap.jpg)

***SOAP*** — протокол доступа к объектам — протокол (HTTP) обмена структурированными сообщениями в распределённой вычислительной среде (удаленный вызов). 

***XML*** - Формат передачи данных
<br/>
(от англ. eXtensible Markup Language) — расширяемый язык разметки. Спецификация XML описывает XML-документы и частично описывает поведение XML-процессоров (программ, читающих XML-документы и обеспечивающих доступ к их содержимому).

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/xml.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/xml1.png)

***XSD (от англ. XML Schema Definition)*** — язык описания структуры XML-документа. Позволяет валидировать входящие данные.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/xsd.png)

***WSDL (от англ. Web Services Description Language)*** — язык описания веб-сервисов и доступа к ним, основанный на языке XML.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/wsdl.png)

***Отличия SOAP от REST***

| API        | Rest                                                  | Soap                             |
| ---------- | ----------------------------------------------------- | -------------------------------- |
| Формат     | XML, Json, HTML                                       | XML                              |
| Регламент  | Swagger                                               | XSD, WSLD                        |
| Применение | Интеграция сервиса с большим кол-вом внешних клиентов | Back to back, внешние интеграции |


***POST*** -   метод направления запросов в SOAP.
 
***Envelop*** - часть SOAP-сообщения является корневой

***Fault*** -  часть SOAP-сообщения передается информация об ошибках

***Преимущества:***

Строгий регламент, 

автоматическая генерация и валидация документа

***Недостатки:***

Размер передаваемых данных XML > JSON

Низкая скорость обработки сообщений

Строгое соблюдение версий


**REST API**

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/restpmap.jpg)

<a name="rest1"></a>

***REST*** — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.
<br/>
не зависит от каких-либо базовых протоколов
<br/>
▪ не накладывает ограничений на формат передаваемых данных

На основе ***HTTP*** принято проектировать и реализовывать REST интеграции и сервисы. 
<br/>
***HTTP (англ. HyperText Transfer Protocol*** — «протокол передачи гипертекста») 

***Архитектурный стиль REST базируется на шести принципах***

***1. Первый принцип - Клиент-серверная архитектура***
<a name="rest2"></a>
<br/>
клиентская часть реализует только функциональное взаимодействие с сервером и отображение информации пользователям. 
<br/>
При этом сервер реализует в себе бизнес-логику, обеспечение хранения данных, взаимодействие с другими системами и сервисами и так далее.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest.png)

***Плюсы***

***Масштабируемость*** - при возникновении потребности, достаточно просто развернуть несколько серверов с приложением и балансировать нагрузку между ними, ровно как и не составляет труда увеличить количество клиентов для сервера.

***Простота развития и поддержки*** - например, при необходимости внесения изменений в логику работы приложения на сервере, эти изменения коснутся только сервера и не будет потребности изменять и дорабатывать каждого клиента.

***Минус***

Взаимодействие по сети в режиме "запрос-ответ" зависит от пропускной способности сети и от ее стабильности - что является недостатком данного типа архитектуры.


***2. Второй принцип - Stateless***
<a name="rest3"></a>

Принцип Stateless  заключается в том, что сервер не должен хранить у себя информацию о состоянии клиента, а каждый запрос со стороны клиента включает всю необходимую информацию для обработки. 

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest1.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest2.png)


***3. Третий принцип - кэширование (Cacheable)***
<a name="rest4"></a>

***Кэш*** — промежуточный буфер с быстрым доступом к нему, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. 

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest3.png)

***Плюсы:***

увеличение быстродействия обмена данными за счет снижения количества взаимодействия по сети
<br/>
увеличение стабильности системы 


***4. Четвертый принцип - единообразие интерфейса (HATEOAS)***
<a name="rest5"></a>

Данный принцип говорит о том, что сервер в ответе на запрос клиента должен возвращать не только сам запрашиваемый объект или ресурс, но и информацию о связях с другими объектами и действия, которые можно над объектом совершать.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest4.png)

Применяя принцип HATEOAS мы еще больше разделяем связанность клиента и сервера, передавая ответственность и свободу действий на сторону клиента. Однако, это ограничение увеличивает объем информации передаваемой по сети и усложняет логику работы клиента. 


***5. Пятый принцип - слоистая архитектура (Layered system)***
<a name="rest6"></a>

Если в цепочке запросов от клиента к серверу вводятся дополнительные участники, например балансировщики, то компонент системы должен "видеть" и "знать" только своих ближайших соседей. 

Знания балансировщика в этой схеме об участниках конкретно этой цепочки вызовов должны заканчиваться клиентским приложением слева и сервером справа, о системе авиаперевозчика он уже ничего знать не должен.

Соответственно изменения, возникающие на уровне балансировщика не должны повлечь изменения для системы авиаперевозчика.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest5.png)

***Минусы***

при добавлении новых компонентов в цепочку взаимодействия, мы увеличиваем число взаимодействий по сети - что приведет к увеличению времени ожидания ответа на стороне клиент

***6. Шестой принцип - Code on demand (код по запросу)***
<a name="rest7"></a>

Этот принцип означает, что сервер в ответ на запрос может отправить исходный код, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.

Если мы рассматриваем приложение покупки авиабилетов, то с одним из ответов от сервера мы можем передать исполнимый код, выполнив который при завершении оплаты на экране будет отображаться фейерверк или какое-то динамическое сообщение. 

В этом случае мы можем один раз внести изменение на стороне сервера, и клиенты будут на своей стороне запускать обновленный код, что не требует доработок на стороне клиента. 

<a name="rest8"></a>
***HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста»)*** — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

***HTTPS (от англ. HyperText Transfer Protocol Secure)*** — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности.

***TLS (от англ. transport layer security)*** — криптографический протокол защиты транспортного уровня, обеспечивающий защищённую передачу данных между узлами в сети Интернет. 

<a name="rest9"></a>
***URL*** (англ. Uniform Resource Locator) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса.

***http/store.com/accessories?type=apple&color=grey***


***Sheme*** - схема. Указывает какой транспортный протокол используется. В данном примере это http.

***Host*** - сервер, к которому мы обращаемся или домен. В данном примере это store.com

***Path*** - путь до конкретного ресурса (объекта) на сервере, что еще и называется Endpoint. В данном примере это /accessories

***?type=apple*** - так называемые query-параметры. Иногда после знака "?" могут указываться несколько параметров, в таком случае они разделяются знаком "&".


***Методы***
<a name="rest10"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/rest6.jpg)


***Идемпотентность*** - свойство метода, которое говорит о том, что многократный вызов метода приводит к одинаковому результату.
<a name="rest11"></a>


| Метод  | Функция              | body | Идемпотентный? |
| ------ | -------------------- | ---- | -------------- |
| GET    | чтение               | -    | ДА             |
| POST   | добавление/запись    | +    | НЕТ            |
| PUT    | перезапись           | +    | ДА             |
| PATCH  | частичная перезапись | +    | НЕТ            |
| DELETE | удаление             | -    | ДА             |


**HTTP-коды ответов**
<a name="rest12"></a>

***1ХХ - Информационные***

***2ХХ - Успешные***

***3ХХ - Перенаправление***

***4ХХ - Ошибки на стороне клиента***

***5ХХ - ошибки на стороне сервера***


***102 Processing*** - это означает что сервер в процессе обработки вашего запроса. 

***200 ОК*** - самый благоприятный ответ. Обозначает что с сервером все хорошо и ваш запрос был принят и обработан успешно.

***301 Moved Permanently*** -  это означает, что запрашиваемый ресурс был перенесен на другой URL.

***400 Bad request*** - это значит, что параметры вашего запроса некорректны.

***401 Unauthorized*** - означает что у вас нет доступа к ресурсу и требуется аутентификация.

***403 Forbidden*** - нет права на осуществления действия.

***404 Not Found*** - ресурс не найден.

***500 Internal Server Error*** - ошибка внутри сервера.

***504 Gateway Timeout*** - время ожидания ответа истекло.


**Транзакция**
<a name="bd1"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/tran.png)

**ACID**
<a name="bd2"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/acid1.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/acid2.png)


**Реляционная база данных**
<a name="bd3"></a>

***В реляционной модели***, как объекты, так и их отношения представлены только таблицами. Основана на реляционной алгебре и включает в себя:

Отношения/Relations
<br/>
Поля/Колонки/Атрибуты/Columns
<br/>
Строки/Rows/Tuples

***Достоинства:***

Простота и доступность для понимания конечным пользователям

Применение математического аппарата реляционной алгебры

Полная независимость данных

Изоляция физической структуры от логической

SQL

ACID

Идеально для КХД

***Недостатки:***

"Дорогой" доступ к данным

Большое кол-во отношений

Не все данные "красиво" зайдут в реляционную модель

Высокая стоимость владения для Корпоративных решений


**NoSQL**
<a name="bd4"></a>

Графовые - вершины, ребра и их свойства.

Объектно-ориентированные

Ключ-значение -  являются по сути словарем, позволяющим извлечь однозначное значение по ключу.

Семейство столбцов - данные хранятся по столбцам, а не по строкам.

Документые - похожи на ключ-значение, только значения с разметкой (XML, JSON), которая и образует "документ".


**МРР СУБД**
<a name="bd5"></a>

MPP ( Massive Parallel Processing) или Массово-параллельная архитектура - это параллельные вычисления на нескольких серверах объединенных в один кластер.

Данные распределены по нескольким row / column store cегментам кластера

Обработка данных как можно ближе к месту их хранения

Мощный интерконнект для обмена порциями данных

Shared Nothing архетиктура

Идеально для OLAP / DWH


![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mrr.png)


***Достоинства:***

Быстрота обработки больших объемов данных 

Легкое горизонательное масштабирование

Отказоустойчивость за счет создания релик/зеркал

Стандартное Hardware для сегментов

Row / Column store

Сжатие хранимых данных

Параллельная загрузка частей данных напрямую в шарды

Cloud Compatibility. Совместимость с облачными решениями.


***Недостатки:***

Высокие требования к элементам инфраструктуры

Низкая производительность на OLTP профиле нагрузки

Ограничения в поддержке всех функций SQL

Возможности возникновения перекосов данных

Специфическая поддержка и обслуживание


***CAP***
<a name="bd6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/cap.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/cap1.png)

**Глоссарий**
<a name="bd7"></a>

***Шардинг*** — метод разделения и хранения единого логического набора данных в виде множества баз данных. Другое определение шардинга — горизонтальное разделение данных.

***Нода*** - объект в базе данных, узел графа (например, сервер).

***Кластер*** - это группа серверов (именуемых "нодами"), которые работают вместе, выполняют общие задачи и клиенты видят их как одну систему.

***Репликация*** - поддержания двух (или более) наборов данных в согласованном состоянии.

***База данных (БД)*** - это организованная коллекция данных хранящаяся и доступная в электронном виде при помощи вычислительных машин.

***Система Управления Базами Данных (СУБД)*** - комплекс программ, позволяющих создать БД и манипулировать данными.

***DDL (Data Definition Language)*** - язык определения данных.

***DML (Data Manipulation Language)*** - язык изменения данных.



**OLAP**
<a name="bd8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/olap.png)

**OLTP**
<a name="bd9"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/oltp.png)