**Виды требований к программному продукту**
<br/>
[1. Бизнес-требования](#т1)
<br/>
[2. Бизнес-правила](#т2)
<br/>
[3. Пользовательские требования](#т3)
<br/>
[4. Системные требования](#т4)
<br/>
[5. Функциональные требования](#т5)
<br/>
[6. Нефункциональные требования](#т6)
<br/>
[7. Ограничения](#т7)
<br/>
[8. Внешние интерфейсы](#т7)

**Классификация НФТ**
<br/>
[1. Производительность](#нфт1)
<br/>
[2. Безопасность](#нфт2)
<br/>
[3. Масштабируемость](#нфт3)
<br/>
[4. Надежность](#нфт4)
<br/>
[5. Совместимость](#нфт5)
<br/>
[6. Доступность](#нфт6)
<br/>
[7. Особенности хранения данных](#нфт7)
<br/>
[8. Концептуальная целостность](#нфт8)
<br/>
[9. Ремонтопригодность](#нфт9)
<br/>
[10. Возможность повторного использования](#нфт10)
<br/>
[11. Удобство использования](#нфт11)
<br/>
[12. Возможность поддержки](#нфт12)
<br/>
[13. Тестируемость](#нфт13)

**Архитектура**
<br/>
[1. Архитектурные слои](#а1)
<br/>
[2. Компонент](#а2)
<br/>
[3. Интерфейс](#а3)
<br/>
[4. Разделение компонентов](#а4)
<br/>
[5. Разделение по принципу согласованного изменения](#а5)
<br/>
[6. Разделение по субдоменам](#а6)
<br/>
[7. По единой функциональности](#а7)
<br/>
[8. Монолит](#а8)
<br/>
[9. SOA](#а9)
<br/>
[10. Микросервисы](#а10)
<br/>
[11. Хорошая архитектура](#а11)
<br/>
[12. Плохая архитектура](#а12)


**Интеграции**
<br/>
[1. Интеграция](#и1)
<br/>
[2. File transfer](#и2)
<br/>
[3. Shared Database](#и3)
<br/>
[4. RPC](#и4)
<br/>
[5. Message](#и5)
<br/>
[6. Синхронное взаимодействие](#и6)
<br/>
[7. Асинхронное взаимодействие](#и7)
<br/>
[8. Асинхронное взаимодействие с callback](#и8)

**Брокеры очередей**
<br/>
[1. Принцип работы очередей сообщений](#б1)
<br/>
[2. Применение брокеров](#б2)
<br/>
[3. Недостатки брокеров](#б3)
<br/>
[4. Брокер сообщений](#б4)
<br/>
[5. Паттерн Hello world](#б5)
<br/>
[6. Паттерн Очередь](#б6)
<br/>
[7. Паттерн Подписка](#б7)
<br/>
[8. Паттерн Маршрутизация](#б8)
<br/>
[9. Паттерн Запрос-ответ](#б9)
<br/>
[10. Сравнение брокеров Kafka/RabbitMQ/Redis](#б10)

**KAFKA VS RabbitMQ**
<br/>
[1. Kafka](#rk1)
<br/>
[2. RabbitMQ](#rk2)
<br/>
[3. KAFKA VS RabbitMQ](#rk3)



«Требование – это удобное представление потребности. Требования направлены на понимание того, какую ценность можно получить, если требование будет выполнено.» BABOK (2015)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/req.png)

<a name="т1"></a>
***1. Бизнес-требования*** (BRQ- business requirements questionnaire) –   информация, в совокупности
описывающая потребность бизнес заказчика, 
а также бизнес возможности и бизнес цели
<br/>
***Примеры:***
<br/>
Увеличить продажи отдела digital-маркетинга на 25% за год.
<br/>
Операционные затраты должны сократиться на 30% после внедрения новой системы.

<a name="т2"></a>
***2. Бизнес-правила*** - это требования, установленные в бизнес-практике, законодательстве или отрасли, которым мы обязаны следовать при реализации нашей системы.
<br/>
***Примеры:***
<br/>
Сайт интернет-магазина должен соответствовать требованиям федерального закона (Закон "О персональных данных" N 152-ФЗ).
<br/>
Клиент компании может оформить заказ с оплатой курьеру. 

<a name="т3"></a>
***3. Пользовательские требования*** (URQ - user requirements questionnaire)- описывают 
цели и задачи, которые пользователи должны иметь возможность выполнять с помощью системы\продукта
<br/>
***Примеры:***
<br/>
Сотрудники первой линии поддержки должны иметь доступ к user-friendly интерфейсу для мониторинга  и решения инцидентов.
<br/>
Сотрудники склада должны иметь возможность формировать промежуточные метрики по расходам сырья.

<a name="т4"></a>
***4. Системные требования*** (SRQ - system requirements questionnaire) – описывают поведение системы или продукта в определенных условиях. Системные требования определяют, какую систему разработчики должны создать, чтобы пользователи могли выполнять свои задачию. По большому счету, все, что надо знать программисту – это структуры данных, необходимые для реализации системы, и алгоритмы, которые ими манипулируют.
<br/>
***Примеры:***
<br/>
Необхоимо разработать мобильное приложение для оформления заказов используя корпоративный фреймворк.
<br/>
Определение типов данных - каждому типу необходимо дать определение, чтобы их реализация не вызывала вопросов у программистов. Например, для атрибута money: содержит вещественное число с точностью до 4-го знака после запятой, число может быть отрицательным и положительным; одновременно со значением система хранит валюту; валюта по умолчанию — российский рубль.

<a name="т5"></a>
***5. Функциональные требования*** (FRQ – functional requirements questionnaire) - описывают
поведение системы или продукта в определенных
условиях. Функциональные требования 
определяют, что разработчики должны создать, 
чтобы пользователи могли выполнять свои задачи
<br/>
***Примеры:***
<br/>
Система должна сохранять информацию по инцидентам и направлять уведомления о сбоях пользователям.
<br/>
Система должна собирать метрики и формировать из них отчет с заданным временным интервалом.

<a name="т6"></a>
***6. Нефункциональные требования*** (NFR - non-functional requirements) описывают как должна работать система или программный продукт и какими свойствами она должна обладать, а также описывают атрибуты качества, ограничения, взаимодействия с внешними интерфейсами.
Атрибуты качества (quality attributes) представляют собой дополнительное описание функций продукта, выраженное через описание его характеристик, важных для пользователей или разработчиков, такие как производительность, надежность, масштабируемость, возможность интеграции c внешними системами.
<br/>
***Примеры:***
<br/>
Система должна обеспечивать интеграцию с сервисами доставки для отправки заказов клиентам.
<br/>
Система должна выдерживать 5000 заказов в день и одновременно 100 сессий.

<a name="т7"></a>
***7. Ограничения*** - представляют собой условия, которые модифицируют требование или набор требований, сужая тем самым выбор возможных решений. Наиболее известными ограничениями являются, технические ограничения, которые часто фиксируются в техническом задании, исходя из возможностей, которыми обладают заказчик или разработчик.
<br/>
***Примеры:***
<br/>
Сервер приложений сайта должен разрабатываться на языке Java. Почему такое требование может быть предъявлено? Возможно, потому что у заказчика имеется большое количество специалистов, способных сопровождать работу системы, написанной на этом языке, а все остальные серверы приложений заказчика также функционируют в этой среде.
<br/>
ПО должно устанавливаться на определенную версию операционной системы (ОС Ubuntu Server 14.04.6).

<a name="т8"></a>
***8. Внешние интерфейсы*** - это описание интерфейса между системой и пользователем, другой системой или оборудованием. Обычно внешние интерфейсы с другими системами уже описаны в виде спецификаций, которым нужно следовать при разработке продукта.
<br/>
***Примеры***:
API социальных сетей для автоматического репоста публикаций с сайта на страничку компании в Facebook. Таким образом, нет необходимости вручную копировать новости, специальное приложение сделает это автоматически.
<br/>
Спецификация взаимодействия с платежным агрегатором для обработки онлайн-платежей на сайте интернет-магазина. Это описание внешнего интерфейса представляет собой определенную спецификацию передачи данных.


**Классификация НФТ**

<a name="нфт1"></a>
***1. Производительность*** - это показатель скорости реакции системы на выполнение любого действия в течение заданного интервала времени. Его можно измерить с точки зрения задержки или пропускной способности. Задержка - это время, необходимое для ответа на любое событие. Пропускная способность - это количество событий, которые происходят в течение заданного промежутка времени.
<br/>
***Пример:*** 
<br/>
Система должна выводить пользователю сообщение о подтверждении в среднем за 3 секунды и не более чем через 6 секунд после того, как пользователь отослал информацию системе.
<br/>
***Чек-лист***
<br/>
какие функции системы завязаны/влияют на взаимодействие с внешними (по отношению к предприятию-заказчику) агентами: клиентами, гос. органами.
<br/>
в какие периоды времени могут происходить пиковые нагрузки исходя из бизнесконтекста и процессов.

<a name="нфт2"></a>
***2. Безопасность*** - это способность системы предотвращать злонамеренные или случайные действия, выходящие за рамки запланированного использования, а также предотвращать раскрытие или потерю информации. Защищенная система направлена на защиту активов и предотвращение несанкционированного изменения информации.
<br/>
***Пример:***
Допускается использование только учетных записей с доменной аутентификацией ActiveDirectory
<br/>
***Чек-лист***
<br/>
что случится, если данные по функции будут доступны всем.
<br/>
есть данные, которые не должны быть доступны и почему

<a name="нфт3"></a>
***3. Масштабируемость***  - это способность системы либо справляться с увеличением нагрузки без влияния на производительность системы, либо возможность быстрого расширения.
<br/>
***Пример:***
<br/>
Система должна обеспечивать масштабируемость до 1000 пользователей с сохранением текущего уровня производительности
***Чек-лист***
<br/>
 уточнить про масштабы текущего внедрения: в каких орг. единицах и пр.
<br/>
будет ли дальнейшее расширение использования системы.
<br/>
какой тренд (динамика) развития бизнес-направления.

<a name="нфт4"></a>
***4. Надежность*** - это способность системы оставаться в рабочем состоянии в течение долгого времени. Надежность измеряется как вероятность того, что система не откажется выполнять свои функции в течение определенного интервала времени.
<br/>
***Пример:***
<br/>
Система должна обеспечивать время восстановление после сбоя не более 2 часов
<br/> 
***Чек-лист***
<br/>
какие последствия повлечет за собой отключение (временная
недоступность) разрабатываемой системы или функции системы.
<br/>
сколько система может не работать (если может).

<a name="нфт5"></a>
***5. Совместимость*** - это способность системы или различных систем успешно работать, обмениваясь информацией с другими внешними системами, написанными и управляемыми внешними сторонами. Совместимая система упрощает обмен и повторное использование информации как внутри компании, так и за ее пределами.
<br/>
***Пример:***
<br/>
Система должна функционировать на ОС Windows XP/7/8/10
<br/> 
***Чек-лист***
<br/>
по данному пункту лучше осуществлять коммуникацию с архитекторами и
командой разработки. От заказчика в лучшем случае можно получить
ограничения по бюджету.

<a name="нфт6"></a>
***6. Доступность*** - определяет время, в течение которого система функционирует и работает. Его можно измерить как процент от общего времени простоя системы за заранее определенный период. Доступность будет зависеть от системных ошибок, проблем с инфраструктурой, злонамеренных атак и загрузки системы.
<br/>
***Пример:***
<br/>
Система должна быть доступна 98% времени в период 5:00 - 00:00, и 90% времени в период 00:00 - 5:00, за исключением времени планового обслуживания
<br/> 
***Чек-лист***
<br/>
требуется ли доступность 24/7 или бизнес-процессы имеют разрывы
(например выходные дни)
<br/>
будет ли система использоваться в разных часовых поясах.

<a name="нфт7"></a>
***7. Особенности хранения данных*** - это все, что связано с резервированием, с доступом к данным, со скоростью доступа к данным.
<br/>
***Пример:***
<br/>
Раз в неделю необходимо производить резервное копирование данных и хранить их в течение трех лет.

<a name="нфт8"></a>
***8. Концептуальная целостность*** - определяет последовательность системы и последовательность всего дизайна. Сюда входит способ разработки компонентов или модулей, а также такие факторы, как стиль кодирования и именование переменных.
Пример:
GUI (graphical user interface) системы должен разрабатываться на основе стандартной библиотеки (корпоративный UI Kit)

<a name="нфт9"></a>
***9. Ремонтопригодность*** - это возможность быстрого внесения изменений в систему, насколько сложно внести какие-либо изменения. 
***Пример:***
Требования к тому, что система должна позволять вносить изменения без кодинга, только через настройки.

<a name="нфт10"></a>
***10. Возможность повторного использования*** - определяет способность компонентов и подсистем быть подходящими для использования в других приложениях и в других сценариях. Возможность повторного использования сводит к минимуму дублирование компонентов, а также время внедрения.
***Пример:***
Код на котором разработано приложение должен быть написан с использованием стандартных библиотек и фреймворков, чтобы его можно было легко переносить на другие проекты.

<a name="нфт11"></a>
***11. Удобство использования*** определяет, насколько хорошо приложение соответствует требованиям пользователя и потребителя, будучи интуитивно понятным, простым в локализации и глобализации, обеспечивая хороший доступ для пользователей с ограниченными возможностями и приводя к хорошему общему пользовательскому опыту.
<br/>
***Пример:***
<br/>
Интерфейс системы должен быть выполнен в темных цветовых тонах, т.к. эксплуатация пользователем будет осуществляться в условиях низкого уровня освещения»
<br/> 
***Чек-лист***
<br/>
Выявить круг конечных пользователей, провести первичный анализ
условий их работы и особенности пользовательского поведения.

<a name="нфт12"></a>
***12. Возможность поддержки*** - это способность системы предоставлять информацию, полезную для выявления и решения проблем, когда она работает неправильно.
***Пример:***
Требование к логированию ошибок и к сбору информации, который в итоге поможет поддерживать систему и анализировать ошибки.

<a name="нфт13"></a>
***13. Тестируемость*** - это мера того, насколько легко создать критерии тестирования для системы и ее компонентов и выполнить эти тесты для определения соответствия критериям. Хорошая тестируемость повышает вероятность того, что сбои в системе могут быть локализованы своевременно и эффективно.
***Пример:***
Требование к тому, насколько легко тестировать нашу систему, нужны ли для этого какие-то специальные инструменты, софт или, например, к возможности автоматизированного тестирования.

<br/>

**Прикладная архитектура**

***1. Прикладная архитектура информационной системы*** – это
форма, которая придаётся системе её создателями

<a name="а1"></a>

***Форма системы*** образуется посредством деления системы на
компоненты, и определяется их организацией и способами
взаимодействия друг с другом и внешними системами

***Цель создания такой формы*** – упростить разработку,
развёртывание и сопровождение программной системы
Неверные архитектурные решения труднее всего поддаются
изменениям на этапе разработки и эксплуатации системы


***Концепция слоёв*** – подход, используемый при проектировании сложных
систем, предполагающий разделение системы на более простые части

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/client_server.png)

***Расслоение системы***
<br/>
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/layer.png)


***Дополнительные слои***
<br/>
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/dop_layer.png)

<a name="а2"></a>

***2. Логический компонент*** - замещаемая часть системы, которая соответствует некоторому набору интерфейсов и
обеспечивает их реализацию

***Физический компонент*** – это единица развёртывания, представляющая наименьшую сущность, которую можно развернуть в
составе системы. Например – jar-файлы, dll-файлы, exe-файлы. С точки зрения разработки, компонент – это
отдельный проект/модуль исходного кода системы

<a name="а3"></a>

***3. Интерфейс*** – это набор операций, которые специфицируют сервис (так называемая спецификация сервиса)
Интерфейс сам по себе не содержит никакой прикладной логики. Он определяет операции (методы), которые
поддерживает компонент.
<br/>
В компоненте реализуется логика, описанных в интерфейсе операций.

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/intface.png)

<a name="а4"></a>

***4. Зачем разделять систему на компоненты?*** 

Обеспечить независимую разработку и развёртывание в случае большой команды разработчиков
<br/>
Снизить влияние изменений, вносимых в одну часть системы, на другую часть системы
<br/>
Иметь возможность заменять один компонент на другой – аналогичный по интерфейсу, но отличный
по реализации
<br/>
Иметь возможность тестировать отдельные части системы без привлечения других частей

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp.png)

***Принципы разделения компонентов*** 

***5. Разделение по принципу согласованного изменения***  –
один компонент должен реализовывать бизнес-логику
вариантов использования для одного актора – т.е.
только этот актор может инициировать изменение
этого компонента

<a name="а5"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp1.png)

***6. Разделение по субдоменам (bounded contexts)***
 – внутри
одного компонента реализуется логика работы с
ограниченным контекстом предметной области

<a name="а6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp2.png)


***7. Разделение по принципу единой функциональности*** и
переиспользования – если у нескольких компонентов
есть общие функции, то эти функции могут быть
вынесены в отдельный компонент

<a name="а7"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/comp3.png)

**8. Монолит**

<a name="а8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/monolit.png)

***Преимущества и недостатки монолита***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/monolit1.png)

***Применение***

Небольшая команда разработчиков

Система должна решать ограниченный круг бизнес-задач

Функциональность системы не планирует расширятся на другие предметные области

Для MVP в гибких методологиях разработки (принцип Monolith First)

**9. SOA**

<a name="а9"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soa.png)

Взаимодействие между сервисами
осуществляется через ***корпоративную шину данных (ESB)*** по унифицированному
протоколу обмена (например, SOAP).
Сервисы публикуют свои интерфейсы на
шине

***Сервисы ничего не знают друг о друге***, но
знают об интерфейсах и методах, которые
предоставляет ESB

На ESB также публикуются различные
служебные сервисы, обеспечивающие
журналирование, авторизацию, мониторинг
и т.д.

Подход ESB предполагает ***единое хранилище данных***

***Преимущества и недостатки SOA***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/soa1.png)

***Применение***

Интеграция разнородных приложений в большой корпорации

Много команд разработки

Множество решаемых бизнес-задач

**10. Микросервисы**

<a name="а10"></a>

***Микросервис*** представляет
собой сочетание как сервиса
бизнес-логики, так и средств
хранения данных

Прямое ***межсервисное взаимодействие должно быть
сведено к минимуму***. Иначе микросервисная архитектура
превратится в модульный монолит

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc.png)


***Преимущества и недостатки Микросервисов***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc1.png)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/mcsrvc2.png)


***Применение***

Реализация больших корпоративных систем с нуля

Для реализации множеством команд разработчиков

Множество решаемых бизнес-задач и предметных областей, которые должны работать в системе
независимо, но требуют постоянной интеграции


**11. Хорошая архитектура**

<a name="а11"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/arch1.png)

**12. Плохая архитектура**

<a name="а12"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/arch2.png)

**Интеграции**

<a name="и1"></a>

***1. Интеграция*** – передача данных от одной системы в другую

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int.png)

***2. File transfer***
<a name="и2"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int1.png)

***Применение:***
<br/>
Обмен между системами происходит раз в сутки и 2 системы не user-friendly для интеграций


***3. Shared Database***
<a name="и3"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int2.png)

***Применение:***
<br/>
Много систем, необходимо читать, записывать и архивировать данные 
<br/>
Система не знает пришли/записались ли данные и постоянно отправляет запрос в БД


***4. Remote Procedure Call (RPC)***
<a name="и4"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int3.png)

***Применение:***
<br/>
Система А вызывает удаленную функцию у системы B, данные не сохраняются  (REST/SOAP APi)
<br/>
Обе системы должны быть доступны

***5. Message***
<a name="и5"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int4.png)

***Применение:***
<br/>
Транспорт данных быстрее чем у БД, данные временно хранятся в брокере, есть оповещение действий (Kafka/Rabbit MQ)

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/int5.png)


***Синхронное взаимодействие***
<a name="и6"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/sin.png)


***Асинхронное взаимодействие***
<a name="и7"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/asin.png)

***Асинхронное взаимодействие с callback***
<a name="и8"></a>

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/asinc.png)

***Принцип работы очередей сообщений***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker.png)

***Применение брокеров***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker2.png)

***Недостатки брокеров***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker3.png)

***Брокер сообщений***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker1.png)


***Паттерн Hello world***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb1.png)

***Паттерн Очередь***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb2.png)

2 Consumer получают сообщения из одной очереди в здананом порядке
<br/>
С помощью партиций можно распределять нагрузку

***Паттерн Подписка***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb3.png)

2 очереди с разными типами сообщений для каждого Consumer

***Паттерн Маршрутизация***
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb4.png)

Реализуется сложная логика мапинга типов очередей
<br/>
2 пула: пул для всех ошибок и пул только для критических ошибок

***Паттерн Топики***
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb5.png)

Более сложная фильтраци (например через регулярки)

***Паттерн Запрос-ответ***
![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/pb6.png)

2 очереди для запроса и ответа (RabbitMq)

***Сравнение брокеров***

![Image alt](https://github.com/dmatwe/projects/blob/main/Полезное/Системный%20анализ/png/broker4.png)


***Kafka*** - масштабируемая, производительная и гибкая система передачи сообещний и управления очередями для:

***1)Связи микросерисов между собой***
<br/>
***Пример:*** подписка триггер на обновления других частей системы  

***2)Организация потоков данных*** 
<br/>
***Пример:*** стрим событий, при котором на каждом этапе производятся различные манипуляции с данными 

***3)Агрегация данных***
<br/>
***Пример:*** в Kafka формировать метрики и результат записывать в БД

***4)Сбор логов***
<br/>
***Пример:*** краткосрочное хранение логов для разгрузки бд и систем логирования   

***RabbitMQ***
<br/>
Брокер сообщений который состоит из:
<br/>
Mnesia - распределенная СУБД реального времени, написанная на языке программирования Erlang. 
<br/>
Сервер, библиотеки и плагины
<br/>
Имеет возможность горизонтального масштабирования 

***Процесс отправки сообщений:***
<br/>
Publisher -> exchange 
<br/>
1.Отправители отправляют сообщения на обменники
<br/>
2.Обменники отправляют полученные сообщения на другие обменники и в очереди 
<br/>
3.При получении сообщений rabbitMq отправляет подтверждение отправителям
<br/>
4.Получатели постоянно поддерживают TCP-соединение с RabbitMq и объявляют какую очередь они получают 
<br/>
5. rabbitMq проталкивает push сообщения получателям 
<br/>
6.Получатели отправляют подтверждение успеха или ошибки получения сообщения
<br/>
7.После успешного получения сообщение удаляется из очереди


***KAFKA VS RabbitMQ***

| Тип                    | Kafka                                                                                                                                                                                                                                              | RabbitMQ                                                                                                                                                                                                                                                                 |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Обработка сообщений    | Добавляет сообщения журнал, а получатель сам забирает сообщение                                                                                                                                                                                    | Помещает сообщение в очередь (FIFO first input, first output) и отслеживает статус                                                                                                                                                                                       |
| Удаление               | Хранит сообщение до плановой чистки журнала (может сохранять историчность)                                                                                                                                                                         | Удаляет сообщение после его доставки получателю                                                                                                                                                                                                                          |
| Распределение нагрузки | Балансировка нагрузки выполняется автоматически через распределение получателей по partition топика.<br>Позволяет объединять сообщения в пакеты<br>Считается более адаптивной к масштабированию обеспечивая ежедневный обмен миллиардами сообщений | Из-за Push модели возможно переполнение получателей.<br>Каждый получатель запрашивает разное кол-во сообщений, распределение работы может быть неравномерным и возможны задержки.<br>Необходимо ввести ограничения на кол-во скопившихся неподтвержденных сообщений QOS. |
| Маршрутизаиця          | 1 способ записи сообщений на диск без маршрутизации                                                                                                                                                                                                | 4 способа маршрутизации на разные обменники для постановки в различные очереди                                                                                                                                                                                           |
| Хранение данных        | Последовательная запись сообщений в реплеку журнала                                                                                                                                                                                                | Поддерживает порядок в произвольных группах/событиях                                                                                                                                                                                                                     |
| Главное отличие        | Тупой сервер, умный клиент,<br>т.е. логика работы с сообщениями на клиентской стороне                                                                                                                                                              | Умный сервер, тупой клиент,<br>т.е. брокер сам обеспечивает всю логику работы с сообщениями                                                                                                                                                                              |



***Где что использовать:***

***Kafka*** - большая нагрузка, нужна историчность данных.
<br/>
***RabbitMQ*** - real-time, если нужен быстрый обмен сообщениями.